---
layout: post
title: "初遇docker，相见恨晚"
modified:
categories: essay
excerpt:
tags: []
image:
---
称手的工具对于Linux用户来说是不可或缺甚至是决定效率关键因素之一。随着时间的推移，我的Linux工具也在逐渐演化，逐渐形成一个适合自己的系统。我已经形成了自己的Linux的基本软件配置方案，其中包括vim，zsh，colorscheme，git，tmux等等，这些配置统筹为[dotfile](https://github.com/conghui/.dotfile)。这已经成为我装机必备的软件了。里面甚至把个别配置弄得非常复杂，复杂的或许只有我才能知道如何使用，这也是为什么曾有许多人赞赏过我的配置和效率，却少有人延续我这套配置。原因很简单，尽管对于我来说，这套系统条分缕析，但对于他们来说，这无异于monster。遇到问题时，他们无从下手。但我也不会因此而感到遗憾，我的目的并不是为了取悦他们，我只是为了有一套适合我自己的系统罢了。即使是README.md，也许只有我自己能看懂。

一切都过得非常顺利，直到最近在进行FPGA硬件编译。[Maxeler](https://www.maxeler.com/)的平台是我主要进行FPGA开发的平台，在硬件编译的时候往往一次编译就需要耗费几个小时，在测试的时候，常常需要更换参数多次编译，如此下来，完成一组实验往往需要几天的时间甚至更长。等待是一个漫长的过程，而且在等待的过程中工作效率往往不高，爱思考的天性使我开始考虑，如何让多台机器同时编译。

幸运的是，MaxCompiler编译硬件其实并不需要FPGA硬件的支持，只需要软件完备即可。于是我开始在不同的机器上配置硬件编译的环境，一切都非常顺利，直到配置Altera。Altera是Maxcompiler的底层支持，其实Maxcompiler并没有特别神秘的地方，他最终调用的还是硬件上的工具链。但是Altera是需要授权的，授权需要提供MAC地址，主机名，授权也是有期限的。为了让多台机器能够同时使用我仅有的一个Altera license，我开始做了一个很暴力的事情——将所有的机器伪装成被授权的机器。这里包括将不同机器的MAC地址，主机名，系统时间统统修改了。最后，如我所愿，我能够使用多台机器同时硬件编译，编译效率大大提升。但是，这些机器都被我弄得惨不忍睹，几个重要的标示符都相同了，有时我甚至无法分辨了。

配置硬件编译环境是一套较为复杂并且繁琐的工作。讨厌重复工作的我希望进行一次配置，保存这个配置，然后在别的机器导入这个配置就可以完成所有工作。

我的第一个想法是放弃对实体机的修改，使用虚拟机，因为在虚拟机里面可以非常方便配置各种参数而不会影响宿主机。虚拟机，本人了解并常用的有[virtualbox](https://www.virtualbox.org/wiki/Downloads)以及[vmware](http://www.vmware.com/)。可是此时此景，我竟都不喜欢他们。原因很简单，他们都显得略微笨重。试想，如果每次编译我都需要打开一个虚拟机，然后弹出GUI界面，然后再挂载相应的目录，最后才是编译。显然，这个流程有点过于复杂，最重要的是，我觉得虚拟机带来的额外开销太大了。大多数情况，我是在远程到另外一台服务器上工作，总不能让我在服务器上装一个虚拟机，然后打开一个GUI吧？

我希望有一个command line能够完成的工具。

于是，[docker](https://www.docker.com/)登场了。

docker最初为我所用，便是为了完成Maxcompiler的硬件编译。现在回过头看来，流程非常简单，安装docker，制作一个docker image，导出image，然后再另外一台安装了docker的机器上导入这个image即可。所有的工作都在command line下完成，非常舒服，非常方便。

比较有趣的是制作image的过程，我非常欣赏Dockerfile的工作机理。从前的我如果需要安装一个比较复杂的软件，我会花很多时间写一个安装的脚本，期待下次执行脚本完成所有的工作。但是安装脚本也有局限。

1. 首先就是无法控制初始的操作系统，尤其是Linux，有众多的发行版，一般的安装脚本只会针对其中一种发行版，在其他发行版则不适用。

2. 另外一个局限则在安装的过程中，很容易忽略一些依赖关系，比如安装jekyll，需要ruby，也许我的机器上已经提前有了适合版本的ruby，我就把这个依赖忽略了，而这个script到了别的机器由于没有安装ruby而使得整个script失效。

3. 即时有一个非常完备的script，也需要在每台机器上执行一遍，这在效率上，尤其是涉及到下载文件的时候，显得有点力不从心。有什么办法能够通过一次简单的拷贝完成吗？

以上这三点，Docker都非常优雅地帮我解决了。Dockerfile一定程度上充当了script的功能，他也把每一步的命令记录下来了，而且他还是基于一个特定的base image，这就保证了一个相同的初始条件。这个base image很好的把前面两点解决了。至于第三点，其实Dockerfile本身无法解决，但是docker能解决。对于docker image来说，一个image可能仅仅扮演用户需要运行的一个应用，尽管他其实是一个五脏俱全的操作系统（虚拟机）。只要把这个镜像导出，然后再另外一台机器上导入这个镜像即可，甚至都不需要重新生成一次docker image。打个比方，从Dockerfile到docker image的过程就像是源文件到二进制的编译过程，这个二进制是通用的，跨平台的，像java程序一样。java程序需要JVM，docker image需要docker engine。

从这个角度来考虑，这确实是一个一劳永逸的工作，把一个docker image做好，或许可以用很长时间。

我目前做了两个docker image，一个是[conghui/maxcompiler](https://hub.docker.com/r/conghui/maxcompiler/), 另一个是[conghui/jekyll](https://hub.docker.com/r/conghui/jekyll/)。

docker其实跟我的dotfile有相似之处，都是为了一次配置，多处使用。需要考虑的是把什么放到dotfile中，而把什么制作成docker images。这也许是一个值得深思的问题，本文暂不考虑。